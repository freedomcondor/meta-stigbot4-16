From b86ba20073c64de5db1576a1b7b37426118b5a0c Mon Sep 17 00:00:00 2001
From: Condor3397 <freedomcondor@126.com>
Date: Wed, 16 May 2018 10:13:01 +0200
Subject: [PATCH] ov5640changedfrommichael

---
 drivers/media/i2c/ov5640.c | 101 ++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 99 insertions(+), 2 deletions(-)

diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index d5b36f8f3302..c699e62b6054 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -316,7 +316,8 @@ static const struct reg_value ov5640_init_setting_30fps_VGA[] = {
 	{0x583b, 0x28, 0, 0}, {0x583c, 0x42, 0, 0}, {0x583d, 0xce, 0, 0},
 	{0x5025, 0x00, 0, 0}, {0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0},
 	{0x3a1b, 0x30, 0, 0}, {0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0},
-	{0x3a1f, 0x14, 0, 0}, {0x3008, 0x02, 0, 0}, {0x3c00, 0x04, 0, 300},
+	//{0x3a1f, 0x14, 0, 300}, {0x3008, 0x02, 0, 300}, {0x3c00, 0x04, 0, 300},
+	{0x3a1f, 0x14, 0, 0}, {0x3c00, 0x04, 0, 300},
 };
 
 static const struct reg_value ov5640_setting_30fps_VGA_640_480[] = {
@@ -595,7 +596,8 @@ static const struct reg_value ov5640_setting_30fps_720P_1280_720[] = {
 	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x4713, 0x02, 0, 0},
 	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
 	{0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0}, {0x4005, 0x1a, 0, 0},
-	{0x3008, 0x02, 0, 0}, {0x3503, 0,    0, 0},
+	//{0x3008, 0x02, 0, 0}, {0x3503, 0,    0, 0},
+	{0x3503, 0,    0, 0},
 };
 
 static const struct reg_value ov5640_setting_15fps_720P_1280_720[] = {
@@ -827,6 +829,10 @@ static int ov5640_write_reg(struct ov5640_dev *sensor, u16 reg, u8 val)
 	if (ret < 0) {
 		v4l2_err(&sensor->sd, "%s: error: reg=%x, val=%x\n",
 			__func__, reg, val);
+
+								pr_err("ov5640 error : ret = %d",ret);
+								dump_stack();
+				
 		return ret;
 	}
 
@@ -1627,8 +1633,11 @@ static int ov5640_restore_mode(struct ov5640_dev *sensor)
 {
 	int ret;
 
+									pr_err("Harry said: restore mode");
+
 	/* first load the initial register values */
 	ret = ov5640_load_regs(sensor, &ov5640_mode_init_data);
+									pr_err("Harry said: restore mode after load, ret = %d",ret);
 	if (ret < 0)
 		return ret;
 
@@ -1664,20 +1673,38 @@ static void ov5640_reset(struct ov5640_dev *sensor)
 static int ov5640_set_power_on(struct ov5640_dev *sensor)
 {
 	int ret;
+
+									pr_err("Harry said: ov5640 set_power_on before 1");
+
 	/* enable clock */
 	gpiod_set_value_cansleep(sensor->clock_enable_gpio, 1);
+
+									pr_err("Harry said: ov5640 set_power_on before 2");
+
 	/* enable dvdd */
 	gpiod_set_value_cansleep(sensor->dvdd_enable_gpio, 1);
+
+									pr_err("Harry said: ov5640 set_power_on before 3");
+
 	/* enable avdd */
 	gpiod_set_value_cansleep(sensor->avdd_enable_gpio, 1);
 
+									pr_err("Harry said: ov5640 set_power_on before 4");
+
 	ov5640_reset(sensor);
+
+									pr_err("Harry said: ov5640 set_power_on after reset");
+
 	ov5640_power(sensor, true);
 
+									pr_err("Harry said: ov5640 set_power_on after power");
+
 	ret = ov5640_init_slave_id(sensor);
 	if (ret)
 		goto power_off;
 
+									pr_err("Harry said: ov5640 set_power_on after slave");
+
 	return 0;
 
 power_off:
@@ -1706,15 +1733,30 @@ static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
 {
 	int ret = 0;
 
+									pr_err("Harry said: ov5640 set_power before set_power");
+
 	if (on) {
 		ret = ov5640_set_power_on(sensor);
 		if (ret)
 			return ret;
 
+									pr_err("Harry said: ov5640 set_power after set_power_on");
+									pr_err("gpiod get value: avdd:  %d",
+										gpiod_get_value_cansleep(sensor->avdd_enable_gpio)  );
+									pr_err("gpiod get value: dvdd:  %d",
+										gpiod_get_value_cansleep(sensor->dvdd_enable_gpio)  );
+									pr_err("gpiod get value: clock: %d",
+										gpiod_get_value_cansleep(sensor->clock_enable_gpio)  );
+									pr_err("sleeping");
+
+									msleep(50);
+
 		ret = ov5640_restore_mode(sensor);
 		if (ret)
 			goto power_off;
 
+									pr_err("Harry said: ov5640 set_power after restore mode");
+
 		if (sensor->ep.bus_type == V4L2_MBUS_CSI2) {
 			/*
 			 * start streaming briefly followed by stream off in
@@ -1723,10 +1765,17 @@ static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
 			ret = ov5640_set_stream_mipi(sensor, true);
 			if (ret)
 				goto power_off;
+
+									pr_err("Harry said: ov5640 set_power after set_stream true");
+
 			usleep_range(1000, 2000);
 			ret = ov5640_set_stream_mipi(sensor, false);
+
 			if (ret)
 				goto power_off;
+
+									pr_err("Harry said: ov5640 set_power after set_stream false");
+
 		}
 
 		return 0;
@@ -1744,29 +1793,42 @@ static int ov5640_s_power(struct v4l2_subdev *sd, int on)
 	struct ov5640_dev *sensor = to_ov5640_dev(sd);
 	int ret = 0;
 
+									pr_err("Harry said: ov5640 s_power start");
+									
 	mutex_lock(&sensor->lock);
 
+									pr_err("Harry said: ov5640 s_power after mutex");
+
 	/*
 	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
 	 * update the power state.
 	 */
+
+									pr_err("Harry said: ov5640 s_power before set_power");
+
 	if (sensor->power_count == !on) {
 		ret = ov5640_set_power(sensor, !!on);
 		if (ret)
 			goto out;
 	}
 
+									pr_err("Harry said: ov5640 s_power after set_power");
+
 	/* Update the power count. */
 	sensor->power_count += on ? 1 : -1;
 	WARN_ON(sensor->power_count < 0);
 out:
 	mutex_unlock(&sensor->lock);
 
+									pr_err("Harry said: ov5640 s_power after unlock mutex");
+
 	if (on && !ret && sensor->power_count == 1) {
 		/* restore controls */
 		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
 	}
 
+									pr_err("Harry said: ov5640 s_power after v4l2 ctrl");
+
 	return ret;
 }
 
@@ -2390,18 +2452,25 @@ static int ov5640_check_chip_id(struct ov5640_dev *sensor)
 	struct i2c_client *client = sensor->i2c_client;
 	int ret = 0;
 	u16 chip_id;
+	
+									pr_err("Harry said: in check chip id");
 
 	ret = ov5640_set_power_on(sensor);
 	if (ret)
 		return ret;
 
+									pr_err("Harry said: after power on");
+
 	ret = ov5640_read_reg16(sensor, OV5640_REG_CHIP_ID, &chip_id);
+									pr_err("Harry said: after read ret = %d",ret);
 	if (ret) {
 		dev_err(&client->dev, "%s: failed to read chip identifier\n",
 			__func__);
 		goto power_off;
 	}
 
+							pr_err("Harry said: in check chip after read, chip id = 0x%x",chip_id);
+
 	if (chip_id != 0x5640) {
 		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x5640, got 0x%x\n",
 			__func__, chip_id);
@@ -2421,6 +2490,9 @@ static int ov5640_probe(struct i2c_client *client,
 	struct ov5640_dev *sensor;
 	int ret;
 
+									pr_err("Harry said: ov5640 start");
+
+
 	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
 	if (!sensor)
 		return -ENOMEM;
@@ -2439,6 +2511,9 @@ static int ov5640_probe(struct i2c_client *client,
 
 	sensor->ae_target = 52;
 
+									pr_err("ov5640 before parse endpoint");
+
+
 	endpoint = fwnode_graph_get_next_endpoint(
 		of_fwnode_handle(client->dev.of_node), NULL);
 	if (!endpoint) {
@@ -2446,6 +2521,9 @@ static int ov5640_probe(struct i2c_client *client,
 		return -EINVAL;
 	}
 
+									pr_err("ov5640 middle parse endpoint");
+
+
 	ret = v4l2_fwnode_endpoint_parse(endpoint, &sensor->ep);
 	fwnode_handle_put(endpoint);
 	if (ret) {
@@ -2453,6 +2531,9 @@ static int ov5640_probe(struct i2c_client *client,
 		return ret;
 	}
 
+									pr_err("ov5640 after parse endpoint");
+
+
 	/* request clock enable pin */
 	sensor->clock_enable_gpio =
 		devm_gpiod_get(dev,"clock-enable", GPIOD_OUT_HIGH);
@@ -2464,6 +2545,10 @@ static int ov5640_probe(struct i2c_client *client,
 			sensor->xclk_freq);
 		return -EINVAL;
 	}
+	
+									pr_err("ov5640 after get clk");
+
+									pr_err("ov5640 before get powerdown and reset");
 
 	/* request optional power down pin */
 	sensor->pwdn_gpio =
@@ -2481,6 +2566,9 @@ static int ov5640_probe(struct i2c_client *client,
 	if (ret)
 		return ret;
 
+
+									pr_err("ov5640 before get regulators");
+
 	/* request avdd supply enable pin */
 	sensor->avdd_enable_gpio =
 		devm_gpiod_get(dev,"avdd-enable", GPIOD_OUT_HIGH);
@@ -2490,18 +2578,27 @@ static int ov5640_probe(struct i2c_client *client,
 
 	mutex_init(&sensor->lock);
 
+
+									pr_err("ov5640 before check chip id");
+
 	ret = ov5640_check_chip_id(sensor);
 	if (ret)
 		goto entity_cleanup;
 
+									pr_err("ov5640 after check chip id");
+
 	ret = ov5640_init_controls(sensor);
 	if (ret)
 		goto entity_cleanup;
 
+									pr_err("ov5640 after init control");
+
+
 	ret = v4l2_async_register_subdev(&sensor->sd);
 	if (ret)
 		goto free_ctrls;
 
+									pr_err("ov5640 after async");
 	return 0;
 
 free_ctrls:
-- 
2.14.1


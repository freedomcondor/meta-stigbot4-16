From 7491b30e9db2887a3db81bc1b3047b76db39a4f2 Mon Sep 17 00:00:00 2001
From: Condor3397 <freedomcondor@126.com>
Date: Wed, 13 Jun 2018 10:08:02 +0200
Subject: [PATCH] ov5640driverchanged

---
 drivers/media/i2c/ov5640.c | 124 ++++++++++++++++++++++-----------------------
 1 file changed, 61 insertions(+), 63 deletions(-)

diff --git a/drivers/media/i2c/ov5640.c b/drivers/media/i2c/ov5640.c
index e2dd352224c7..826c4734e421 100644
--- a/drivers/media/i2c/ov5640.c
+++ b/drivers/media/i2c/ov5640.c
@@ -8,9 +8,6 @@
  * (at your option) any later version.
  */
 
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/clkdev.h>
 #include <linux/ctype.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -21,7 +18,6 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/gpio/consumer.h>
-#include <linux/regulator/consumer.h>
 #include <media/v4l2-async.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
@@ -31,6 +27,7 @@
 /* min/typical/max system clock (xclk) frequencies */
 #define OV5640_XCLK_MIN  6000000
 #define OV5640_XCLK_MAX 24000000
+#define OV5640_XCLK_FIXED 24000000
 
 #define OV5640_DEFAULT_SLAVE_ID 0x3c
 
@@ -118,6 +115,7 @@ static const struct ov5640_pixfmt ov5640_formats[] = {
 	{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_SRGB, },
 	{ MEDIA_BUS_FMT_RGB565_2X8_LE, V4L2_COLORSPACE_SRGB, },
 	{ MEDIA_BUS_FMT_RGB565_2X8_BE, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_COLORSPACE_SRGB, },
 };
 
 /*
@@ -134,15 +132,6 @@ static const int ov5640_framerates[] = {
 	[OV5640_30_FPS] = 30,
 };
 
-/* regulator supplies */
-static const char * const ov5640_supply_name[] = {
-	"DOVDD", /* Digital I/O (1.8V) suppply */
-	"DVDD",  /* Digital Core (1.5V) supply */
-	"AVDD",  /* Analog (2.8V) supply */
-};
-
-#define OV5640_NUM_SUPPLIES ARRAY_SIZE(ov5640_supply_name)
-
 /*
  * Image size under 1280 * 960 are SUBSAMPLING
  * Image size upper 1280 * 960 are SCALING
@@ -188,6 +177,8 @@ struct ov5640_ctrls {
 	struct v4l2_ctrl *contrast;
 	struct v4l2_ctrl *hue;
 	struct v4l2_ctrl *test_pattern;
+
+	struct v4l2_ctrl *pixel_rate;
 };
 
 struct ov5640_dev {
@@ -195,10 +186,11 @@ struct ov5640_dev {
 	struct v4l2_subdev sd;
 	struct media_pad pad;
 	struct v4l2_fwnode_endpoint ep; /* the parsed DT endpoint info */
-	struct clk *xclk; /* system clock to OV5640 */
 	u32 xclk_freq;
 
-	struct regulator_bulk_data supplies[OV5640_NUM_SUPPLIES];
+	struct gpio_desc *avdd_enable_gpio;
+	struct gpio_desc *dvdd_enable_gpio;
+	struct gpio_desc *clock_enable_gpio;
 	struct gpio_desc *reset_gpio;
 	struct gpio_desc *pwdn_gpio;
 
@@ -937,7 +929,7 @@ static int ov5640_load_regs(struct ov5640_dev *sensor,
 			ret = ov5640_mod_reg(sensor, reg_addr, mask, val);
 		else
 			ret = ov5640_write_reg(sensor, reg_addr, val);
-		if (ret)
+		if ((ret) && (reg_addr != 0x3008))
 			break;
 
 		if (delay_ms)
@@ -1674,23 +1666,13 @@ static void ov5640_reset(struct ov5640_dev *sensor)
 
 static int ov5640_set_power_on(struct ov5640_dev *sensor)
 {
-	struct i2c_client *client = sensor->i2c_client;
 	int ret;
-
-	ret = clk_prepare_enable(sensor->xclk);
-	if (ret) {
-		dev_err(&client->dev, "%s: failed to enable clock\n",
-			__func__);
-		return ret;
-	}
-
-	ret = regulator_bulk_enable(OV5640_NUM_SUPPLIES,
-				    sensor->supplies);
-	if (ret) {
-		dev_err(&client->dev, "%s: failed to enable regulators\n",
-			__func__);
-		goto xclk_off;
-	}
+	/* enable clock */
+	gpiod_set_value_cansleep(sensor->clock_enable_gpio, 1);
+	/* enable dvdd */
+	gpiod_set_value_cansleep(sensor->dvdd_enable_gpio, 1);
+	/* enable avdd */
+	gpiod_set_value_cansleep(sensor->avdd_enable_gpio, 1);
 
 	ov5640_reset(sensor);
 	ov5640_power(sensor, true);
@@ -1703,17 +1685,24 @@ static int ov5640_set_power_on(struct ov5640_dev *sensor)
 
 power_off:
 	ov5640_power(sensor, false);
-	regulator_bulk_disable(OV5640_NUM_SUPPLIES, sensor->supplies);
-xclk_off:
-	clk_disable_unprepare(sensor->xclk);
+	/* disable avdd */
+	gpiod_set_value_cansleep(sensor->avdd_enable_gpio, 0);
+	/* disable dvdd */
+	gpiod_set_value_cansleep(sensor->dvdd_enable_gpio, 0);
+	/* disable clock */
+	gpiod_set_value_cansleep(sensor->clock_enable_gpio, 0);
 	return ret;
 }
 
 static void ov5640_set_power_off(struct ov5640_dev *sensor)
 {
 	ov5640_power(sensor, false);
-	regulator_bulk_disable(OV5640_NUM_SUPPLIES, sensor->supplies);
-	clk_disable_unprepare(sensor->xclk);
+	/* disable avdd */
+	gpiod_set_value_cansleep(sensor->avdd_enable_gpio, 0);
+	/* disable dvdd */
+	gpiod_set_value_cansleep(sensor->dvdd_enable_gpio, 0);
+	/* disable clock */
+	gpiod_set_value_cansleep(sensor->clock_enable_gpio, 0);
 }
 
 static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
@@ -1918,6 +1907,10 @@ static int ov5640_set_framefmt(struct ov5640_dev *sensor,
 	u8 val;
 
 	switch (format->code) {
+	case MEDIA_BUS_FMT_UYVY8_1X16:
+		/* YUV422, UYVY */
+		val = 0x32;
+		break;
 	case MEDIA_BUS_FMT_UYVY8_2X8:
 		/* YUV422, UYVY */
 		val = 0x3f;
@@ -2119,6 +2112,15 @@ static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 			return val;
 		sensor->ctrls.exposure->val = val;
 		break;
+	case V4L2_CID_PIXEL_RATE:
+		if (!ctrl->val)
+			return 0;
+		val = ov5640_get_sysclk(sensor) * 10000;
+		if (val < 0)
+			return val;
+		sensor->ctrls.pixel_rate->val = val;
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate, val);
+		break;
 	}
 
 	return 0;
@@ -2224,6 +2226,13 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 					     ARRAY_SIZE(test_pattern_menu) - 1,
 					     0, 0, test_pattern_menu);
 
+	ret = ov5640_set_power_on(sensor);
+	if (ret)
+		return ret;
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+				       0, INT_MAX, 1, ov5640_get_sysclk(sensor) * 10000);
+	ov5640_set_power_off(sensor);
+						
 	if (hdl->error) {
 		ret = hdl->error;
 		goto free_ctrls;
@@ -2231,6 +2240,7 @@ static int ov5640_init_controls(struct ov5640_dev *sensor)
 
 	ctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
 	ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_VOLATILE;
 
 	v4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);
 	v4l2_ctrl_auto_cluster(2, &ctrls->auto_gain, 0, true);
@@ -2399,18 +2409,6 @@ static const struct v4l2_subdev_ops ov5640_subdev_ops = {
 	.pad = &ov5640_pad_ops,
 };
 
-static int ov5640_get_regulators(struct ov5640_dev *sensor)
-{
-	int i;
-
-	for (i = 0; i < OV5640_NUM_SUPPLIES; i++)
-		sensor->supplies[i].supply = ov5640_supply_name[i];
-
-	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
-				       OV5640_NUM_SUPPLIES,
-				       sensor->supplies);
-}
-
 static int ov5640_check_chip_id(struct ov5640_dev *sensor)
 {
 	struct i2c_client *client = sensor->i2c_client;
@@ -2479,14 +2477,11 @@ static int ov5640_probe(struct i2c_client *client,
 		return ret;
 	}
 
-	/* get system clock (xclk) */
-	sensor->xclk = devm_clk_get(dev, "xclk");
-	if (IS_ERR(sensor->xclk)) {
-		dev_err(dev, "failed to get xclk\n");
-		return PTR_ERR(sensor->xclk);
-	}
+	/* request clock enable pin */
+	sensor->clock_enable_gpio =
+		devm_gpiod_get(dev,"clock-enable", GPIOD_OUT_HIGH);
 
-	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	sensor->xclk_freq = OV5640_XCLK_FIXED;
 	if (sensor->xclk_freq < OV5640_XCLK_MIN ||
 	    sensor->xclk_freq > OV5640_XCLK_MAX) {
 		dev_err(dev, "xclk frequency out of range: %d Hz\n",
@@ -2495,11 +2490,11 @@ static int ov5640_probe(struct i2c_client *client,
 	}
 
 	/* request optional power down pin */
-	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
-						    GPIOD_OUT_HIGH);
+	sensor->pwdn_gpio =
+		devm_gpiod_get_optional(dev, "powerdown", GPIOD_OUT_HIGH);
 	/* request optional reset pin */
-	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
-						     GPIOD_OUT_HIGH);
+	sensor->reset_gpio =
+		devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
 
 	v4l2_i2c_subdev_init(&sensor->sd, client, &ov5640_subdev_ops);
 
@@ -2510,9 +2505,12 @@ static int ov5640_probe(struct i2c_client *client,
 	if (ret)
 		return ret;
 
-	ret = ov5640_get_regulators(sensor);
-	if (ret)
-		return ret;
+	/* request avdd supply enable pin */
+	sensor->avdd_enable_gpio =
+		devm_gpiod_get(dev,"avdd-enable", GPIOD_OUT_HIGH);
+	/* request dvdd supply enable pin */
+	sensor->dvdd_enable_gpio =
+		devm_gpiod_get(dev,"dvdd-enable", GPIOD_OUT_HIGH);
 
 	mutex_init(&sensor->lock);
 
-- 
2.14.1

